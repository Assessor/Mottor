# Mottor

Реализовал как можно проще. Так как реализация простая, комментариев в коде нет.

Использовал шаблон проектирование "Наблюдатель" из стандартной библиотеки SPL для реализации наблюдение за каждым посетителем в определенный момент времени. Это позволит в дальнейшем добавить другое любое действие, например, "Уйти из клуба".

"Очередь" реализована стандартными функциями для работы с массивами: array_shift, array_push. Новый посетитель добавляется в конец очереди и ждет своего права на заказ музыки. Очередь циклична, так как нет метода "Уйти из клуба".

Источником данных для жанров может служить любое хранилище, будь то БД, файлы, память и т.д. Сейчас источником данных выступает массив зашитый в исходники кода. Для добавления нового источника нужно реализовать соответсвующий интерфейс DataProvider.

Функции автозагрузки не писал и не использовал composer, но делать это умею.

Пример работы:

$dataProvider = new \Mottor\DataProvider\InMemory();

$guests[] = new \Mottor\Entity\Guest('Ivanov', $dataProvider, [3, 4]); // 3, 4 - ключи жанров
$guests[] = new \Mottor\Entity\Guest('Petrov', $dataProvider); // без указания ключей, посетителюнравятся все жанры
$guests[] = new \Mottor\Entity\Guest('Smirnov', $dataProvider, [5,6]);

$run = new \Mottor\Controller\Run();

foreach ($guests as $guest) {
    $run->attach($guest);
}

echo '<br />' . '--- Запуск музыки ---' . PHP_EOL . '<br />';
$run->turnMusic();

echo '<br />' . '--- Пришел новый посетитель ---' . PHP_EOL . '<br />';
$run->attach(new \Mottor\Entity\Guest('Kapustin', $dataProvider, [1]));

echo '<br />' . '--- Музыка закончилась. Выполняется заказ сл. посетителя в порядке очереди ---' . PHP_EOL . '<br />';
$run->turnMusic();
